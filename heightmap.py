from grid import Grid
from cell import Cell
import random
import constants as c


class Heightmap():
    def __init__(self, grid: Grid, start_x: int, start_y: int,
                 min_random: int = -1, max_random: int = 3,
                 exponent=4):
        """Generates a heightmap on an area of size 2**exponent + 1,
        using the diamond square algorithm.
        Corner elevation and middle point elevation is immediately set.
        The rest of the heightmap can be generated by calling next_iteration.
        Heightmaps can be created in steps of 2**exponent cells.
        This will cause heightmaps to slightly overlap.
        The heightmap doesn't have to be entirely within grid bounds.
        Non-mountainous cells will get minimum elevation.
        A cell will only be given a new elevation if it's current elevation is None. 
        """
        self.grid = grid
        self.start_x: int = start_x
        self.start_y: int = start_y
        self.min_random: float = min_random
        self.max_random: float = max_random
        self.size: int = 2 ** exponent + 1
        self.step: int = 2 ** exponent

        # Try skipping the flat edges. They are likely to sharp lines
        # self._set_flat_edges(grid, start_x, start_y, self.size)
        self._randomize_elevation(grid, start_x, start_y)
        self._randomize_elevation(grid, start_x + self.size - 1, start_y)
        self._randomize_elevation(grid, start_x, start_y + self.size - 1)
        self._randomize_elevation(grid, start_x + self.size - 1,
                                  start_y + self.size - 1)

        self._diamond_step(self.grid, self.start_x, self.start_y,
                           self.size, self.step, self.min_random, self.max_random)

    def _randomize_elevation(self, grid: Grid, x: int, y: int) -> None:
        """Generates a random starting elevation for a cell.
        The value is chosen from 0 to twice the mountain depth.
        If elevation is not None, the cell retains its current elevation."""
        try:
            cell = grid.get(x, y)

            if cell.elevation == None and c.is_terrain(cell.terrain, c.MOUNTAIN):
                self._set_elevation(cell, random.randrange(
                    0, 1 + cell.mountain_depth * 2))
            elif cell.elevation == None:
                self._set_elevation(cell, 0)
        except KeyError as e:
            pass

    def _set_flatlands(self, grid: Grid, x: int, y: int) -> None:
        """If the cell is not mountainous, its elevation is set to 0
        and will not change."""
        try:
            cell = grid.get(x, y)

            if c.is_terrain(cell.terrain, c.MOUNTAIN) == False:
                cell.elevation = 0
        except KeyError:
            pass

    def _set_flat_edges(self, grid: Grid, start_x: int, start_y: int, size: int) -> None:
        """Checks the edges of the heightmap for any non-mountainous cells.
        Sets the elevation of those cells to 0."""
        for x in range(start_x, start_x + size):
            self._set_flatlands(grid, x, start_y)
            self._set_flatlands(grid, x, start_y + size - 1)

        for y in range(start_y + 1, start_y + size - 1):
            self._set_flatlands(grid, start_x, y)
            self._set_flatlands(grid, start_x + size - 1, y)

    def _set_elevation(self, cell: Cell, elevation: int) -> None:
        """Sets elevation of a cell. Only applies if the cells elevation is None.
        Changes cell terrain as needed"""
        if cell.elevation == None:
            # Ban negative elevation for now. It creates odd looking lakes
            # cell.elevation = max(elevation, 0)
            # cell.elevation = min(cell.elevation, 16)
            # Allow negative elevation again
            # It might be acceptable now that I've manipulated the weights
            cell.elevation = min(elevation, 15)

    def _get_weight(self, x: int, y: int) -> int:
        """Returns the weight of a cell. Cells with high weights
        have greater influence on the elevation of other cells."""
        # Corner cells will now have doubled weight.
        # Hopefully, this will solve problems where corner cell elevation
        # was likely to be different from surrounding elevation
        # and create smoother transitions.
        # The middle cell now has doubled weight as well.
        if (x == self.start_x or x == self.start_x + self.size - 1) and \
                (y == self.start_y or y == self.start_y + self.size - 1):
            return 2
        elif (x == self.start_x + self.size // 2) or \
                (y == self.start_y + self.size // 2):
            return 2
        else:
            return 1

    def _get_elevation(self, grid: Grid, x: int, y: int) -> int:
        """Returns the elevation of a cell. Returns 0 if elevation is None
        or if there's no cell at the coordinate"""
        try:
            cell = grid.get(x, y)

            if cell.elevation == None:
                return 0
            else:
                return cell.elevation
        except KeyError as e:
            return 0

    def _get_random(self, min_random: float, max_random: float) -> float:
        """Returns a random value from min_random to max_random"""
        return min_random + random.random() * (max_random - min_random)

    def _diamond_step(self, grid: Grid, start_x: int, start_y: int, size: int,
                      step: int, min_random: float, max_random: float) -> None:
        half = step // 2

        for x in range(start_x + half, start_x + size, step):
            for y in range(start_y + half, start_y + size, step):
                try:
                    cell = grid.get(x, y)
                except KeyError as e:
                    continue

                ne_weight = self._get_weight(x + half, y - half)
                se_weight = self._get_weight(x + half, y + half)
                sw_weight = self._get_weight(x - half, y + half)
                nw_weight = self._get_weight(x - half, y - half)

                northeast = self._get_elevation(grid, x + half, y - half)
                southeast = self._get_elevation(grid, x + half, y + half)
                southwest = self._get_elevation(grid, x - half, y + half)
                northwest = self._get_elevation(grid, x - half, y - half)

                total = ne_weight + se_weight + sw_weight + nw_weight
                value = (ne_weight * northeast + se_weight * southeast
                         + sw_weight * southwest + nw_weight * northwest) / total

                if cell.terrain == c.MOUNTAIN:
                    result = value + self._get_random(min_random, max_random)
                else:
                    result = value

                self._set_elevation(cell, result)

    def _square_step(self, grid: Grid, start_x: int, start_y: int, size: int,
                     step: int, min_random: float, max_random: float) -> None:
        half = step // 2

        for x in range(start_x, start_x + size, half):
            for y in range(start_y + (x + half) % step, start_y + size, step):
                try:
                    cell = grid.get(x, y)
                except KeyError as e:
                    continue

                n_weight = self._get_weight(x, y - half)
                e_weight = self._get_weight(x + half, y)
                s_weight = self._get_weight(x, y + half)
                w_weight = self._get_weight(x - half, y)

                north = self._get_elevation(grid, x, y - half)
                east = self._get_elevation(grid, x + half, y)
                south = self._get_elevation(grid, x, y + half)
                west = self._get_elevation(grid, x - half, y)

                total = n_weight + e_weight + s_weight + w_weight
                value = (n_weight * north + e_weight * east
                         + s_weight * south + w_weight * west) / total

                if cell.terrain == c.MOUNTAIN:
                    result = value + self._get_random(min_random, max_random)
                else:
                    result = value
                self._set_elevation(cell, result)

    def _generate_heights(self, grid: Grid, start_x: int, start_y: int,
                          exponent: int, min_random: int, max_random) -> None:
        """Generates a heightmap on an area of size 2^exponent + 1.
        Uses the diamond square algorithm."""
        # TODO to be deprecated

        size = 2 ** exponent + 1
        step = 2 ** exponent

        while (step > 1):
            self._diamond_step(grid, start_x, start_y,
                               size, step, min_random, max_random)
            self._square_step(grid, start_x, start_y,
                              size, step, min_random, max_random)
            min_random = min_random / 2
            max_random = max_random / 2
            step = step // 2

    def _round_all(self) -> None:
        """Rounds all elevation values to integers"""
        for x in range(self.start_x, self.start_x + self.size):
            for y in range(self.start_y, self.start_y + self.size):
                try:
                    cell = self.grid.get(x, y)
                    cell.elevation = round(cell.elevation)

                    if cell.elevation > 0:
                        cell.set_terrain(c.MOUNTAIN)
                    elif cell.elevation == 0 and c.is_terrain(cell.terrain, c.MOUNTAIN):
                        cell.set_terrain(c.LAND)
                    elif cell.elevation < 0:
                        cell.set_terrain(c.WATER)
                except KeyError:
                    pass

    def next_iteration(self) -> bool:
        """Perform a square step and a diamond step.
        The square step is dependent on neighboring heightmaps.
        All heightmaps should be generated to the same level of iteration
        before the next iteration is performed.
        Returns true if heightmap is completed."""
        if self.step <= 1:
            return False

        self._square_step(self.grid, self.start_x, self.start_y,
                          self.size, self.step, self.min_random, self.max_random)
        self.min_random = self.min_random / 2
        self.max_random = self.max_random / 2
        self.step = self.step // 2

        if self.step > 1:
            self._diamond_step(self.grid, self.start_x, self.start_y,
                               self.size, self.step, self.min_random, self.max_random)
            return False
        else:
            # Remove rounding in the algorithm and round now instead
            # Hopefully, that'll add some smoothness
            # It doesn't solve the problems of dots
            # I could to a neighbor-check to correct isolated elevation
            # It'd take some extra time
            self._round_all()
            # Try stretching high elevation cells to the north
            # That's funny. I can't use it here. I'll have to call it from world
            # in order of northern heightmaps to southern
            # Some pixels just shoot up. That's no good
            # self.tilt()
            return True

    def stretch_north(self, x: int, y: int):
        try:
            cell = self.grid.get(x, y)

            if cell.elevation <= 1:
                return

            for z in range(1, cell.elevation):
                high_cell = self.grid.get(x, y - z)
                high_cell.set_terrain(c.MOUNTAIN)
                high_cell.elevation = cell.elevation
        except KeyError:
            pass

    def tilt(self):
        """Stretches cells to the north depending on elevation,
        in order to create a three-dimensional feel.
        To account for heightmap overlap, the last cells are not tilted."""
        for y in range(self.start_y, self.start_y + self.size - 1):
            for x in range(self.start_x, self.start_x + self.size - 1):
                self.stretch_north(x, y)


# Testing!
if __name__ == "__main__":
    grid: Grid = Grid(17, 17)

    for cell in grid:
        cell.set_terrain(c.MOUNTAIN)
        cell.mountain_depth = 1

    grid.get(0, 0).elevation = 0
    grid.get(16, 0).elevation = 0
    grid.get(0, 16).elevation = 0
    grid.get(16, 16).elevation = 0

    # for x in range(9):
    #     grid.get(x, 0).set_terrain(c.LAND)
    #     grid.get(x, 0).mountain_depth = 0

    # Given that 1 elevation = 500km and 1 cell = 1000km,
    # a difference of 2 equals a 45 degree slope
    # In which case a max_random of 8 would correspond to a 45 degree slope
    # or 4000 km height increase
    # Which I consider acceptable
    # However, I may want to consider 1 elevation = 1000km.
    # Then those 4000km rises would look better.

    # Values of min random, max random
    # 0, 2: too smooth, needs to be zoomed out
    # 0, 8: I never see smooth slopes down to 0
    # After I added weight to corners, I see I have steep slopes
    # around the middle, so I may want to increase weight there as well
    # 0, 4: better, with a few slopes down to 0 but not enough
    # Smooth slopes overall, maybe a bit too smooth
    # The middle often sticks out too much
    # Adding extra weight to the middle helps but it's still not ideal
    # 0, 6: slopes are decently sharp but not too much so
    # No slopes down to 0
    # -1, 3: smooth with low terrain. Many 0 elevations
    # Changed to allow negatives
    # -1, 3: similar to before. Negatives very rare
    # -1, 5: fairly smooth
    # -2, 4: there are plenty of lakes
    # While that's nice, it might cause issues at the border
    # Decent sharpness
    # -2, 6: fewer lakes, higher peaks. Decent sharpness
    # Slopes to 0 are fine enough
    # -2, 5: something like this is fine

    # -2, 4 on map: it's not too bad. Many irregular shapes.
    # Lakes are few but when they do appear, they're good enough.
    # Try adding the tilt now.
    # It I have a large mountain area, it doesn't look good at all.
    # Try with higher elevation.
    # -2, 6 on map: nah. I can't expect too much from this algorithm.
    # With tilt, I get these drawn-out lines.
    # It should be better to use low randomness and increase color contrast.
    # Then I might get some decent enough mountains.
    # I believe -2, 4 is better than -2, 6.
    heightmap: Heightmap = Heightmap(grid, 0, 0,
                                     min_random=-2, max_random=5, exponent=4)

    heightmap.next_iteration()
    heightmap.next_iteration()
    heightmap.next_iteration()
    heightmap.next_iteration()

    for y in range(heightmap.size):
        print()
        for x in range(heightmap.size):
            print(f"{grid.get(x, y).elevation:>2}", end=" ")
    print()
