from grid import Grid
from cell import Cell
import random
import constants as c


class Heightmap():
    def __init__(self, grid: Grid, start_x: int, start_y: int,
                 min_random: int = -1, max_random: int = 3,
                 exponent=4):
        """Generates a heightmap on an area of size 2**exponent + 1,
        using the diamond square algorithm.
        Corner elevation and middle point elevation is immediately set.
        The rest of the heightmap can be generated by calling next_iteration.
        Heightmaps can be created in steps of 2**exponent cells.
        This will cause heightmaps to slightly overlap.
        The heightmap doesn't have to be entirely within grid bounds.
        Non-mountainous cells will get minimum elevation.
        A cell will only be given a new elevation if it's current elevation is None. 
        """
        self.grid = grid
        self.start_x: int = start_x
        self.start_y: int = start_y
        self.min_random: float = min_random
        self.max_random: float = max_random
        self.size: int = 2 ** exponent + 1
        self.step: int = 2 ** exponent

        # Try skipping the flat edges. They are likely to sharp lines
        # self._set_flat_edges(grid, start_x, start_y, self.size)
        self._randomize_elevation(grid, start_x, start_y)
        self._randomize_elevation(grid, start_x + self.size - 1, start_y)
        self._randomize_elevation(grid, start_x, start_y + self.size - 1)
        self._randomize_elevation(grid, start_x + self.size - 1,
                                  start_y + self.size - 1)

        self._diamond_step(self.grid, self.start_x, self.start_y,
                           self.size, self.step, self.min_random, self.max_random)

    def _randomize_elevation(self, grid: Grid, x: int, y: int) -> None:
        """Generates a random starting elevation for a cell.
        The value is chosen from 0 to twice the mountain depth.
        If elevation is not None, the cell retains its current elevation."""
        try:
            cell = grid.get(x, y)

            if cell.elevation == None and c.is_terrain(cell.terrain, c.MOUNTAIN):
                self._set_elevation(cell, random.randrange(
                    0, 1 + cell.mountain_depth * 2))
            elif cell.elevation == None:
                self._set_elevation(cell, 0)
        except KeyError as e:
            pass

    def _set_flatlands(self, grid: Grid, x: int, y: int) -> None:
        """If the cell is not mountainous, its elevation is set to 0
        and will not change."""
        try:
            cell = grid.get(x, y)

            if c.is_terrain(cell.terrain, c.MOUNTAIN) == False:
                cell.elevation = 0
        except KeyError:
            pass

    def _set_flat_edges(self, grid: Grid, start_x: int, start_y: int, size: int) -> None:
        """Checks the edges of the heightmap for any non-mountainous cells.
        Sets the elevation of those cells to 0."""
        for x in range(start_x, start_x + size):
            self._set_flatlands(grid, x, start_y)
            self._set_flatlands(grid, x, start_y + size - 1)

        for y in range(start_y + 1, start_y + size - 1):
            self._set_flatlands(grid, start_x, y)
            self._set_flatlands(grid, start_x + size - 1, y)

    def _set_elevation(self, cell: Cell, elevation: int) -> None:
        """Sets elevation of a cell. Only applies if the cells elevation is None.
        Changes cell terrain as needed"""
        if cell.elevation == None:
            # Ban negative elevation for now. It creates odd looking lakes
            cell.elevation = max(elevation, 0)
            cell.elevation = min(elevation, 16)

            if cell.elevation > 0:
                cell.set_terrain(c.MOUNTAIN)
            elif cell.elevation < 0:
                cell.set_terrain(c.WATER)
            elif c.is_terrain(cell.terrain, c.MOUNTAIN):
                cell.set_terrain(c.LAND)

    def _get_elevation(self, grid: Grid, x: int, y: int) -> int:
        """Returns the elevation of a cell. Returns 0 if elevation is None
        or if there's no cell at the coordinate"""
        try:
            cell = grid.get(x, y)

            if cell.elevation == None:
                return 0
            else:
                return cell.elevation
        except KeyError as e:
            return 0

    def _get_random(self, min_random: float, max_random: float) -> float:
        """Returns a random value from min_random to max_random"""
        return min_random + random.random() * (max_random - min_random)

    def _diamond_step(self, grid: Grid, start_x: int, start_y: int, size: int,
                      step: int, min_random: float, max_random: float) -> None:
        half = step // 2

        for x in range(start_x + half, start_x + size, step):
            for y in range(start_y + half, start_y + size, step):
                try:
                    cell = grid.get(x, y)
                except KeyError as e:
                    continue

                northeast = self._get_elevation(grid, x + half, y - half)
                southeast = self._get_elevation(grid, x + half, y + half)
                southwest = self._get_elevation(grid, x - half, y + half)
                northwest = self._get_elevation(grid, x - half, y - half)
                value = (northeast + southeast + southwest + northwest) / 4

                if cell.terrain == c.MOUNTAIN:
                    result = value + self._get_random(min_random, max_random)
                else:
                    result = value

                self._set_elevation(cell, result)

    def _square_step(self, grid: Grid, start_x: int, start_y: int, size: int,
                     step: int, min_random: float, max_random: float) -> None:
        half = step // 2

        for x in range(start_x, start_x + size, half):
            for y in range(start_y + (x + half) % step, start_y + size, step):
                try:
                    cell = grid.get(x, y)
                except KeyError as e:
                    continue

                north = self._get_elevation(grid, x, y - half)
                east = self._get_elevation(grid, x + half, y)
                south = self._get_elevation(grid, x, y + half)
                west = self._get_elevation(grid, x - half, y)
                value = (north + east + south + west) / 4

                if cell.terrain == c.MOUNTAIN:
                    result = value + self._get_random(min_random, max_random)
                else:
                    result = value
                self._set_elevation(cell, result)

    def _generate_heights(self, grid: Grid, start_x: int, start_y: int,
                          exponent: int, min_random: int, max_random) -> None:
        """Generates a heightmap on an area of size 2^exponent + 1.
        Uses the diamond square algorithm."""
        # TODO to be deprecated

        size = 2 ** exponent + 1
        step = 2 ** exponent

        while (step > 1):
            self._diamond_step(grid, start_x, start_y,
                               size, step, min_random, max_random)
            self._square_step(grid, start_x, start_y,
                              size, step, min_random, max_random)
            min_random = min_random / 2
            max_random = max_random / 2
            step = step // 2

    def _round_all(self) -> None:
        """Rounds all elevation values to integers"""
        for x in range(self.start_x, self.start_x + self.size):
            for y in range(self.start_y, self.start_y + self.size):
                try:
                    cell = self.grid.get(x, y)
                    cell.elevation = round(cell.elevation)

                    if cell.elevation == 0 and c.is_terrain(cell.terrain, c.MOUNTAIN):
                        cell.set_terrain(c.LAND)
                    elif cell.elevation < 0:
                        cell.set_terrain(c.WATER)
                except KeyError:
                    pass

    def next_iteration(self) -> bool:
        """Perform a square step and a diamond step.
        The square step is dependent on neighboring heightmaps.
        All heightmaps should be generated to the same level of iteration
        before the next iteration is performed.
        Returns true if heightmap is completed."""
        self._square_step(self.grid, self.start_x, self.start_y,
                          self.size, self.step, self.min_random, self.max_random)
        self.min_random = self.min_random / 2
        self.max_random = self.max_random / 2
        self.step = self.step // 2

        if self.step > 1:
            self._diamond_step(self.grid, self.start_x, self.start_y,
                               self.size, self.step, self.min_random, self.max_random)
            return False
        else:
            # Remove rounding in the algorithm and round now instead
            # Hopefully, that'll add some smoothness
            # It doesn't solve the problems of dots
            # I could to a neighbor-check to correct isolated elevation
            # It'd take some extra time
            self._round_all()
            return True


# Testing!
if __name__ == "__main__":
    grid: Grid = Grid(9, 9)

    for cell in grid:
        cell.set_terrain(c.MOUNTAIN)
        cell.mountain_depth = 1

    # for x in range(9):
    #     grid.get(x, 0).set_terrain(c.LAND)
    #     grid.get(x, 0).mountain_depth = 0

    heightmap: Heightmap = Heightmap(grid, 0, 0,
                                     min_random=0, max_random=2, exponent=3)

    for y in range(9):
        print()
        for x in range(9):
            print(grid.get(x, y).elevation, end=" ")
    print()
    input()

    heightmap.next_iteration()

    for y in range(9):
        print()
        for x in range(9):
            print(grid.get(x, y).elevation, end=" ")
    print()
    input()

    heightmap.next_iteration()

    for y in range(9):
        print()
        for x in range(9):
            print(grid.get(x, y).elevation, end=" ")
    print()

    heightmap.next_iteration()

    for y in range(9):
        print()
        for x in range(9):
            print(grid.get(x, y).elevation, end=" ")
    print()
